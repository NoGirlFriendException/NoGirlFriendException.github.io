{"meta":{"title":"一只大金毛","subtitle":"Coding as Calling","description":"","author":"bb","url":"http://nogirlfriendexception.github.io"},"pages":[{"title":"Tags","date":"2015-09-30T18:24:55.000Z","updated":"2016-04-27T01:11:30.000Z","comments":true,"path":"tags/index.html","permalink":"http://nogirlfriendexception.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"正确的保存View状态.","slug":"viewsavastate","date":"2017-05-01T02:31:30.000Z","updated":"2017-05-01T03:47:11.000Z","comments":true,"path":"2017/05/01/viewsavastate/","link":"","permalink":"http://nogirlfriendexception.github.io/2017/05/01/viewsavastate/","excerpt":"","text":"前言android 的 View以及ViewGroup保存相应状态是一件很重要的事情,但是最近由于用到了相关的内容, 搜了下国内相关文章,涉及到的很少.可能很多人都在开发的时候忽略掉了这个功能.自己看了下相应的源码以及翻阅了下相关的文章,了解了下相应的知识,于是写下这篇记录,算是给以后自己翻阅做个笔记. 首先我们要明白View 为什么要保存自己的状态? 我咨询了一些做android开发的朋友,给出的答案都是五花八门, 但大部分都是说不关心保存状态这件事, 当我说这样不对的时候,往往得到的回复是我的代码一直好好的啊 没什么问题啊.是的,代码如果不去关心View 保存状态这件事 在大部分时间都是没问题的,但是在一些情况下会出乱子.我举个例子, 我们的Activity A 去Activity B, 这时候A会走 onPause onStop onSaveInstanceState() 的生命周期. 我们要先明白Activity给我们这个onSaveInstanceState()回调时机的意义,来看一下源码的说明 Called to retrieve per-instance state from an activity before being killed so that the state can be restored in {@link #onCreate} or {@link #onRestoreInstanceState} (the {@link Bundle} populated by this method will be passed to both). This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}.意思就是说 这个Activity在被杀死之前 给你一个机会让你保留你希望保存的东西, 而你保存的东西会在什么时候还给你呢, 会在onCreate 或者onRestoreState的时候.之前有人跟我, 我完全可以不用care这个回调啊,我可以在Activity内自己创建一个Member变量容器 去保存我希望保存的内容啊, 这里是我们需要明白的一个关键,那就是 Activity A 去Activity B, Activity A 如果不被系统杀死回收的话,那怎么搞都是没问题的,但是一旦因为内存不足,Activity A被回收掉,你想想,你的Member容器也会随之一起回收掉.等你从Activity B back 回Activity A的时候, 就会丢失掉你所有希望保存的内容.这里有一个小细节就是 会有人不知道怎么去测试 Activity A 去Activity B, 然后Activity A 被回收的情况, 我们的android手机内 开发者模式, 有一个选项叫 不保留活动.打开以后,只要你退出当前的Activity(按home或者去别的Activity), 你当前的Activity 就必定会被系统杀死回收. 看到这里如果不了解这个选项的朋友可以去打开这个选项试试自己的app.或许你会发现打开了新大门..还有一个小细节就是有可能打开这个开关以后你检查了下你的app 然后告诉我说并没有什么问题, 不会有崩溃啊什么的, 要注意,这里的问题是指 本来应该保存的一些内容 或者用户已经加载过 或者用户已经在当前页面做过的一些动作没有被保存,这句话需要仔细去理解一下,然后再check下自己的app,看看是不是会有东西丢失. View 保存State的一些知识点View saveState 与 restoreState 两套动作都是相对应的, 分别有这么几个关键的方法. saveState. void saveHierarchyState(SparseArray container)这个方法是android framework层调用,在需要保存状态的时机. 看下View源码发现通常是不做什么事情的.是直接调用dispatchSaveInstanceState的 void dispatchSaveInstanceState(SparseArray container)这个方法是被saveHierarchyState调用,它内部会调用onSaveInstanceState 方法去拿到一个存储View当前状态的Parcelable对象, 然后存在container中.这里有两个个关键点1 它的第一句就是 if(mId != NO_ID) 才会执行接下来的保存状态的工作,也就是说如果我们的View希望保存状态那么一定要有一个ID,其实这很好理解, 保存着我们View状态的parcelable 是以key value的形式保存在container中的,那么key是我们的id 也是合情合理的.代码如下 非常清晰123456789101112131415protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) &#123; mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED; Parcelable state = onSaveInstanceState(); if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) &#123; throw new IllegalStateException( \"Derived class did not call super.onSaveInstanceState()\"); &#125; if (state != null) &#123; // Log.i(\"View\", \"Freezing #\" + Integer.toHexString(mID) // + \": \" + state); container.put(mID, state); &#125; &#125;&#125; 2 如果当前View是一个ViewGroup那么它会去循环调用每个child的dispatchSaveInstanceState(), 去给child机会保存状态, android这样设计的地方很多, 比如Touch分发 比如 Measure分发等等,这里就不过多表述了.代码如下123456789101112@Overrideprotected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; super.dispatchSaveInstanceState(container); final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) &#123; View c = children[i]; if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123; c.dispatchSaveInstanceState(container); &#125; &#125;&#125; Parcelable onSaveInstanceState()这个方法就很简单了, 是真正干活的地方,保存当前View的状态, 我们写自定义View的时候 也往往是重写该方法去保存我们需要保存的状态. restoreState. void restoreHierarchyState(SparseArray container)对应saveHierarchyState() void dispatchRestoreInstanceState(SparseArray container)对应dispatchSaveInstanceState() void onRestoreInstanceState(Parcelable state)对应onSaveInstanceState() 还有一个方法是需要特殊说明的, 如果你的自定义View需要保存状态, 那么你需要调用setSaveEnabled(true)方法. 当然widgets官方提供的view都是打开了的.你不用操心.看到这里大家应该以及知道了View保存恢复状态的整个流程是什么样的了,一个View 如果想要保存状态,那么只需要做两件事 有id setSaveEnabled(true) 如何保存自己的状态我们已经知道了我们自定义View应该在onSaveInstanceState的时候去保存我们希望保存的状态,那么具体应该怎么去做呢.接下来是示范(炒鸡简单)比如我们的View内有1个int值希望保存下来, 那么我们的代码应该这样写,12345678910111213141516171819202122232425262728293031323334353637383940414243444546private int mState;...@Override public Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); SavedState ss = new SavedState(superState); ss.state = customState; return ss; &#125; @Override public void onRestoreInstanceState(Parcelable state) &#123; SavedState ss = (SavedState) state; super.onRestoreInstanceState(ss.getSuperState()); setCustomState(ss.state); &#125; static class SavedState extends BaseSavedState &#123; int state; SavedState(Parcelable superState) &#123; super(superState); &#125; private SavedState(Parcel in) &#123; super(in); state = in.readInt(); &#125; @Override public void writeToParcel(Parcel out, int flags) &#123; super.writeToParcel(out, flags); out.writeInt(state); &#125; public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = new Parcelable.Creator&lt;SavedState&gt;() &#123; public SavedState createFromParcel(Parcel in) &#123; return new SavedState(in); &#125; public SavedState[] newArray(int size) &#123; return new SavedState[size]; &#125; &#125;; &#125; 一个经验教训.当我们做一个View的时候,那么上面的内容足够让你保存你想要保存的状态. 但是如果是一个ViewGroup的话, 代码或许在某些情况下应该这样去设计,1234567891011121314151617181920212223242526272829@Override public Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); SavedState ss = new SavedState(superState); ss.childrenStates = new SparseArray(); for (int i = 0; i &lt; getChildCount(); i++) &#123; getChildAt(i).saveHierarchyState(ss.childrenStates); &#125; return ss; &#125; @Override public void onRestoreInstanceState(Parcelable state) &#123; SavedState ss = (SavedState) state; super.onRestoreInstanceState(ss.getSuperState()); for (int i = 0; i &lt; getChildCount(); i++) &#123; getChildAt(i).restoreHierarchyState(ss.childrenStates); &#125; &#125; @Override protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; dispatchFreezeSelfOnly(container); &#125; @Override protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) &#123; dispatchThawSelfOnly(container); &#125; 你需要去注意一下在 dispatchSaveInstanceState 和 dispatchRestoreInstanceState,我们并不是使用super方法 去遍历我们的children去挨个保存和恢复状态,而是调用dispatchFreezeSelfOnly 和 dispatchThawSelfOnly 来告诉系统,我这个ViewGroup不需要去挨个找我的child去保存状态,我们(ViewGroup)自己来就可以了.当然并不是说,如果我们写ViewGroup的时候就一定要这样去写,具体情况要根据自己的实际情况去决定.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]},{"title":"android 源生DownloadManager 的两个Crash 坑","slug":"downloadbug","date":"2017-03-17T01:31:30.000Z","updated":"2017-03-17T04:03:12.000Z","comments":true,"path":"2017/03/17/downloadbug/","link":"","permalink":"http://nogirlfriendexception.github.io/2017/03/17/downloadbug/","excerpt":"","text":"如果你的APP使用源生DownloadManager去更新apk,那么下面这3行代码你肯定不陌生,123DownloadManager.Request request = new DownloadManager.Request(Uri.parse(你的APK下载地址));request.setDestinationUri(你的app 本地存储URI));long mDownloadId = mDownloadManager.enqueue(request); IllegalArgumentException这三行代码 最近在一些机型上爆出了java.lang.IllegalArgumentException: UnknownURLcontent://downloads/my_downloads 异常.是崩溃在了mDownloadManager.enqueue(request)这里,跟着代码进去以后123456public long enqueue(Request request) &#123; ContentValues values = request.toContentValues(mPackageName); Uri downloadUri = mResolver.insert(Downloads.Impl.CONTENT_URI, values); long id = Long.parseLong(downloadUri.getLastPathSegment()); return id;&#125; 继续跟进,找到了崩溃的源头, 是 mResolver.insert这句的问题123456789101112131415161718192021public final @Nullable Uri insert(@NonNull Uri url, @Nullable ContentValues values) &#123; Preconditions.checkNotNull(url, \"url\"); IContentProvider provider = acquireProvider(url); if (provider == null) &#123; // 看这里 嘿嘿嘿 throw new IllegalArgumentException(\"Unknown URL \" + url); &#125; try &#123; long startTime = SystemClock.uptimeMillis(); Uri createdRow = provider.insert(mPackageName, url, values); long durationMillis = SystemClock.uptimeMillis() - startTime; maybeLogUpdateToEventLog(durationMillis, url, \"insert\", null /* where */); return createdRow; &#125; catch (RemoteException e) &#123; // Arbitrary and not worth documenting, as Activity // Manager will kill this process shortly anyway. return null; &#125; finally &#123; releaseProvider(provider); &#125;&#125; 原因是系统的DownloadManager Service被关闭了, 遇见这种问题, 可以有两种解决方法1 是通过产品角度去告知用户,让用户去系统里找到相应的开关 打开下载服务,2 是catch 住这个IllegalArgumentException 然后不再使用downloadmanager 而是自己去手写下载, 就可以解决. SecurityException这三行代码在某些机器上会爆出SecurityException，原因是Context.getExternalFilesDir得到的地址 和Environment.getExternalStorageDirectory() 不一致.具体崩溃代码可以去看源码 的713行.1234567891011121314151617181920212223242526private void checkFileUriDestination(ContentValues values) &#123; String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT); if (fileUri == null) &#123; throw new IllegalArgumentException( \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\"); &#125; Uri uri = Uri.parse(fileUri); String scheme = uri.getScheme(); if (scheme == null || !scheme.equals(\"file\")) &#123; throw new IllegalArgumentException(\"Not a file URI: \" + uri); &#125; final String path = uri.getPath(); if (path == null) &#123; throw new IllegalArgumentException(\"Invalid file URI: \" + uri); &#125; try &#123; final String canonicalPath = new File(path).getCanonicalPath(); final String externalPath = Environment.getExternalStorageDirectory().getAbsolutePath(); if (!canonicalPath.startsWith(externalPath)) &#123; // 看这里,嘿嘿嘿 throw new SecurityException(\"Destination must be on external storage: \" + uri); &#125; &#125; catch (IOException e) &#123; throw new SecurityException(\"Problem resolving path: \" + uri); &#125;&#125; 出现这种bug 我们的解决方案 是自己去拼1个存储地址..所以这三行代码的最终使用是这样的:12345678910111213141516171819DownloadManager.Request request = new DownloadManager.Request(Uri.parse(你的APK下载地址));request.setDestinationUri(你的app 本地存储URI)); try &#123; long mDownloadId = instance.mSystemDownloadManager.enqueue(request); &#125; catch (SecurityException e) &#123; File f = Environment.getExternalStorageDirectory(); f = new File(f, \"Android\"); f = new File(f, \"data\"); f = new File(f, mContext.getPackageName()); f = new File(f, \"files\"); f = new File(f, Environment.DIRECTORY_DOWNLOADS); if (!f.exists()) &#123; f.mkdirs(); &#125; request.setDestinationUri(f)); instance.mDownloadId = instance.mSystemDownloadManager.enqueue(request); &#125; catch (IllegalArgumentException e) &#123; // 自己去写把 要么弹toast告诉用户他傻逼, 要么自己去手写下载 &#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]},{"title":"音视频编码基础技术.","slug":"video_codec","date":"2017-02-24T14:31:30.000Z","updated":"2017-02-26T12:32:08.000Z","comments":true,"path":"2017/02/24/video_codec/","link":"","permalink":"http://nogirlfriendexception.github.io/2017/02/24/video_codec/","excerpt":"","text":"本文参考文章:流媒体系统对比封装格式对比视频编码器对比音频编码格式对比雷霄骅雷神博客HEVCx265编码器 我们平时下载的电影,因为下载的来源不同，这些电影文件有不同的格式，用不同的后缀表示：avi，rmvb，mp4，flv，mkv等等（当然也使用不同的图标）。在这里需要注意的是，这些格式代表的是封装格式。何为封装格式？就是把视频数据和音频数据打包成一个文件的规范。仅仅靠看文件的后缀，很难能看出具体使用了什么视音频编码标准。总的来说，不同的封装格式之间差距不大，各有优劣。注：有些封装格式支持的视音频编码标准十分广泛，应该算比较优秀的封装格式，比如MKV；而有些封装格式支持的视音频编码标准很少，应该属于落后的封装格式，比如RMVB。在此我选用了魔力盒中的一个视频 进行说明.该视频的 后缀为 mp4. Video codec_name 为H.264, Audio codec_name 为 aac.这样我们就可以说 这个视频 采用mp4的QuickTime封装格式（MOV），采用了H.264（AVC）的视频压缩编码标准, AAC的音频编码标准. 接下来说一下我们使用播放器去播放一个视频, 中间发生了什么.视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。 其中解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来 其中几个概念的 特殊说明 流媒体协议流媒体协议是服务器与客户端之间通信遵循的规定。当前网络上主要的流媒体协议如表所示。 主要流媒体协议一览 封装格式封装格式的主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中。现如今流行的封装格式如下表所示： 主要封装格式一览 视频编码视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。视频编码是视音频技术中最重要的技术之一。视频码流的数据量占了视音频总数据量的绝大部分。高效率的视频编码在同等的码率下，可以获得更高的视频质量。 主要视频编码一览由表可见，有两种视频编码方案是最新推出的：VP9和HEVC。目前这两种方案都处于研发阶段，还没有到达实用的程度。当前使用最多的视频编码方案就是H.264。 音频编码音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。音频编码也是互联网视音频技术中一个重要的技术。但是一般情况下音频的数据量要远小于视频的数据量，因而即使使用稍微落后的音频编码标准，而导致音频数据量有所增加，也不会对视音频的总数据量产生太大的影响。高效率的音频编码在同等的码率下，可以获得更高的音质。 主要音频编码一览由表可见，近年来并未推出全新的音频编码方案，可见音频编码技术已经基本可以满足人们的需要。音频编码技术近期绝大部分的改动都是在MP3的继任者——AAC的基础上完成的。 现有网络视音频平台对比现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户，目前还处于发展阶段。直播在网络电视台，社交视频网站较为常见。 直播平台参数对比主流互联网视音频平台直播服务的参数对比如表所示： 现有网络视音频平台参数对比 可以看出，直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。采用RTMP作为直播协议的好处在于其被Flash播放器支持。而Flash播放器如今已经安装在全球99%的电脑上，并且与浏览器结合的很好。因此这种流媒体直播平台可以实现“无插件直播”，极大的简化了客户端的操作。封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。视频播放器方面，都使用了Flash播放器。 点播平台参数对比主流网络视音频平台点播服务的参数对比如表所示： 现有互联网视音频平台参数对比可以看出，点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。视频播放器方面，无一例外的都使用了Flash播放器。 H.265.首先可以明确的是 H265 属于一种视频编码格式, 这里有一篇比较专业的说明, HEVC / H.265 Explained 说到H.265, 就不得不先提一下H.264了, H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。Google推出的VP8属于和H.264同一时代的标准。总体而言，VP8比H.264要稍微差一点。除了在技术领域，VP8和H.264在专利等方面也是打的不可开交。可以武断的说,H264.是现在最主流的视频编码标准.而H.265 是 H.264/MPEG-4 AVC的继任者。目前正在由ISO/IEC MPEG和ITU-T VCEG开发中。为此目的MPEG与VCEG联合成立了一个JCT-VC（JointCollaborative Team on Video Coding）作为共同开发HEVC的团队。HEVC被认为不仅提升图像质量，同时也能达到H.264/MPEG-4 AVC两倍之压缩率（等同于同样画面质量下比特率减少了50%），可支持4K分辨率甚至到超高画质电视，最高分辨率可达到8192×4320（8K分辨率）。第一版的HEVC/H.265视频压缩标准在2013年4月13日被接受为国际电信联盟（ITU-T）的正式标准。VP9是一个由Google开发的开放的视频压缩标准。VP9将是VP8的后继者。VP9的开发始于2011。VP9的目标之一是相同质量下相对于VP8可以减少50%的比特率。而另一个目标就是争取能在压缩效率上高于HEVC。2013年2月21日，第一个支持VP9解码技术的Google Chrome网页浏览器发布了。HEVC VP9 以及x264的性能对比, 结果参考 Dan Grois等人的论文《Performance Comparison of H.265/MPEG-HEVC, VP9, andH.264/MPEG-AVC Encoders》 选用的编码器如下： HEVC：HMVP9：libvpxH.264：x264 HEVC性能最强，奇怪的是x264的性能竟然好于VP9。要知道VP9可是Google推出的下一代编码标准。x264太强悍了！ PS：此外，x264的速度是远远高于HEVC和VP9的。 下表显示了HEVC在同等质量的前提下（以PSNR为依据），相对于VP9和x264节约的码率。下表显示了所有序列的情况。总体来说HEVC相对于VP9节约了41.9%，HEVC相对于x264节约了38.9%。 下表显示了三种编码器整体性能的比较。表中百分比数字的意义是：同等视频质量的前提下，该列所属的编码器相对于该行所属的编码器节约的码率，如果为负值，则代表反而消耗了更多的码率。例如，同等质量的前提下，x264相对于VP9节约了8.4%的码率。 同等视频质量的前提条件下，编码消耗时间对比如下表所示。可以看出，VP9编码时间大约是x264的130倍。HEVC编码时间大约是VP9的7倍。 此外，在码率一定的情况下，几种编码标准结果大致是这样的：HEVC &gt; VP9 &gt; H.264&gt; VP8 &gt; MPEG4 &gt; H.263 &gt; MPEG2。 HEVC 在未来拥有很大的优势, 具体可以参考以下文字段 在数字视频应用产业链的快速发展中，面对视频应用不断向高清晰度、高帧率、高压缩率方向发展的趋势，当前主流的视频压缩标准协议H.264(AVC)的局限性不断凸显。同时，面向更高清晰度、更高帧率、更高压缩率视频应用的HEVC(H.265)协议标准应运而生。本文重点分析了下一代视频压缩协议标准HEVC(H.265)的技术亮点，并对其在未来应用中将给整个产业带来的深刻变化予以展望。 H.264(AVC)从2003年5月草稿发布以来，凭借其相对于以往的视频压缩标准在压缩效率以及网络适应性方面的明显优势，逐步成为视频应用领域的主流标准。根据 MeFeedia的数据，由于iPad以及其它新兴设备大多支持H.264硬件加速，至2011年底，80%的视频使用H.264编码，并且随着支持H.264解码的设备不断增多，这一占有率还将进一步增长。 但是，随着数字视频应用产业链的快速发展，视频应用向以下几个方向发展的趋势愈加明显： (1) 高清晰度(HigherDefinition)：数字视频的应用格式从720 P向1080 P全面升级，在一些视频应用领域甚至出现了4K x 2K、8K x 4K的数字视频格式; (2) 高帧率(Higherframe rate )：数字视频帧率从30fps向60fps、120fps甚至240fps的应用场景升级; (3) 高压缩率(HigherCompression rate )：传输带宽和存储空间一直是视频应用中最为关键的资源，因此，在有限的空间和管道中获得最佳的视频体验一直是用户的不懈追求。 由于数字视频应用在发展中面临上述趋势，如果继续采用H.264编码就出现的如下一些局限性： (1) 宏块个数的爆发式增长，会导致用于编码宏块的预测模式、运动矢量、参考帧索引和量化级等宏块级参数信息所占用的码字过多，用于编码残差部分的码字明显减少。 (2) 由于分辨率的大大增加，单个宏块所表示的图像内容的信息大大减少，这将导致相邻的4 x 4或8 x 8块变换后的低频系数相似程度也大大提高，导致出现大量的冗余。 (3) 由于分辨率的大大增加，表示同一个运动的运动矢量的幅值将大大增加，H.264中采用一个运动矢量预测值，对运动矢量差编码使用的是哥伦布指数编码，该编码方式的特点是数值越小使用的比特数越少。因此，随着运动矢量幅值的大幅增加，H.264中用来对运动矢量进行预测以及编码的方法压缩率将逐渐降低。 (4) H.264的一些关键算法例如采用CAVLC和CABAC两种基于上下文的熵编码方法、deblock滤波等都要求串行编码，并行度比较低。针对GPU/DSP/FPGA/ASIC等并行化程度非常高的CPU，H.264的这种串行化处理越来越成为制约运算性能的瓶颈。 为了面对以上发展趋势，2010年1月，ITU-T VCEG(VideoCoding Experts Group) 和ISO/IEC MPEG(Moving Picture Experts Group)联合成立JCT-VC(JointCollaborative Team on Video Coding)了联合组织，统一制定下一代编码标准：HEVC(High Efficiency Video Coding)。HEVC协议标准计划于2013年2月份正式在业界发布，目前整个框架结构已基本确定。截至2012年4月份，JCT-VC联合工作组已经召开了第八次会议，并于2012年2月17日发布了第一版内部草稿《High efficiency videocoding (HEVC) text specification draft 6》，计划2012年7月发布第一版公开版草稿，在H.264标准2～4倍的复杂度基础上，将压缩效率提升一倍以上。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]},{"title":"WebView开发小记.","slug":"webview","date":"2017-02-16T09:31:30.000Z","updated":"2017-02-16T10:17:58.000Z","comments":true,"path":"2017/02/16/webview/","link":"","permalink":"http://nogirlfriendexception.github.io/2017/02/16/webview/","excerpt":"","text":"最近重构了公司的播放器模块,重新整理了整套代码,并且加入了StateMachine, 然后现在处于提测阶段, 打算在提测确认无bug之后进行一次StateMachine使用的总结,在这个任务空档期,老大安排了我去搞一下公司的WebView模块, 也算是换换脑子. 该文章记录一下几个在开发过程中的小经验 当你使用WebView加载网页的时候, 如果这个网页有JavaScript, 你要跟它进行交互的话,你需要打开开关. 1WebView.getSetting.setJavaScriptEnabled(true); Java与JavaScript 交互比较关键的一个方法是 1WebView.addJavascriptInterface(Object, String); 这个方法简单的来说就是往JavaScript 注入一个可以供他们使用,进行回调的Object, String 就是 这个Object的名字.举例来说:比如 我们在Java代码中 写了这样一段代码 123456WebView.addJavascriptInterface(new Object()&#123; @JavascriptInterface public void inject() &#123; Log.d(TAG, \"Inject success\"); &#125;&#125;, \"InjectObject\"); 而在Javascript中 代码如下 1InjectObject.inject(\"hi, i'm Javascript\"); 这样Java中就可以回调打印出Inject success的字段.这里需要特殊说明的一点就是 addJavascriptInterface的Object 中必须有一个方法是声明 @JavascriptInterface 的, 否则是无法add进去的.并且只有声明了 @JavascriptInterface 的方法 才能被JavaScript 成功调用. Java 和 Javascript 交互的本质是字符串的传递.Java 无论你上层如何封装, 最终将字符串从Java 传到Javascript 都是需要这样去传递的.1WebView.loadUrl(\"javascript:WebViewJavascriptBridge._handleMessageFromJava('%s')\") 其中 javascript: 是必须的. WebViewJavascriptBridge 是Javascript那边的对象,_handleMessageFromJava 是这个对象所拥有的方法. ()内就是要传递过去的字符串!这里有一点需要注意, loadUrl方法会进行checkThread(); 所以也就是说你必须在MainThread中调用该方法. WebView 有内存泄漏的问题, 属于系统代码的1个bug, 在这里我们做了特殊的 WorkAround.12345678910111213141516171819202122private void recycle() &#123; try &#123; MagicWebView thiz = this; thiz.setWebViewClient(null); thiz.setWebChromeClient(null); Field field = View.class.getDeclaredField(\"mContext\"); field.setAccessible(true); field.set(thiz, getContext().getApplicationContext()); field.setAccessible(false); field = View.class.getDeclaredField(\"mParent\"); field.setAccessible(true); field.set(thiz, null); field.setAccessible(false); field = View.class.getDeclaredField(\"mLayoutParams\"); field.setAccessible(true); field.set(thiz, null); field.setAccessible(false); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 这样并不能完全解决WebView 会泄露的问题, WebView 依旧会被泄露, 但是WebView跟相应的Activity 会完全解耦,不会造成Activity也跟着泄露. 在Https的网址下,有的H5图片会加载不正常. 这个时候需要加入这样一个设置123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE);&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]},{"title":"android工程师简历.","slug":"resume","date":"2016-11-02T11:31:30.000Z","updated":"2017-04-21T09:43:30.000Z","comments":true,"path":"2016/11/02/resume/","link":"","permalink":"http://nogirlfriendexception.github.io/2016/11/02/resume/","excerpt":"","text":"","categories":[],"tags":[{"name":"Resume","slug":"Resume","permalink":"http://nogirlfriendexception.github.io/tags/Resume/"}]},{"title":"购房记.","slug":"house","date":"2016-09-29T14:31:30.000Z","updated":"2016-10-07T13:26:20.000Z","comments":true,"path":"2016/09/29/house/","link":"","permalink":"http://nogirlfriendexception.github.io/2016/09/29/house/","excerpt":"","text":"转眼来北京就9年多了,毕业也5年了, 随着年龄越来越大, 以及经历各种合租的痛楚之后,越发的希望自己能有一套自己的房子.原本的计划是在回龙观里买一个商住两用房, 30多平米的那种.买这种小产权的房子也是无奈,北京买房是需要购房资格的,需要连续5年社保.我如果从毕业开始算起,也算是交了5年了,但是中间有一段时间从中华英才网离职,在家学习开发,断交了一段时间.导致我失去了购房资格. 所以如果强行在北京买, 只能买这种小产权的房子. 由于哥哥在回龙观买的房子,所以我毕业以后一直在回龙观这边住,也算是半个观里人了, 对这里比较熟悉,比较依赖.所以优先考虑在回龙观去选了,也基本上只考虑这里了. 仔细观察了下, 符合我要求的房子, 竟然只有一个楼盘.叫东亚上北中心.总结一下这里房子的特点. 优点 因为面积小,只有37平米附近, 大概需要120w附近,总价相对来说比较低. 缺点 小户型. 使用面积只有20多平. 超北 没有阳光 贷款只能走商贷,而且只能10年. 每个月还款压力很大 问了下银行这种房子,我最多只能贷款30w, 也就是说需要至少90W的首付! 这也是一个致命伤, 是我根本承受不起的价格. 以后就算有了孩子,也不能上学.更别说落户了. 做决定的那几天想了很多事情,感觉买这种房子的话,一辈子的生活都要搭进去了, 而且父母那边也要卖掉老家空置的那套房子,然后再加上哥哥的帮忙,也不一定能凑够首付. 所以最后选择了放弃.然后买房这件事就暂时冷了下来,我开始静下来考虑一些漫无边际的事情,大概就是人生啊,生活啊,以后啊云云的.思索了几个月也没思索出什么结果, 反倒是之前看的那个房子又涨了几十万….北京的房子真是令人不能琢磨啊.但是这种漫无边际的涨价到是坚定了我买房的心.脑子不知道怎么回事就冒出了去济南买房的念头,然后跟父母大概提了下,父母对这件事也一直很是上心,是他们的一个心病.考虑去济南的原因大概有这么几个 济南IT行业虽然说不是很好,但是还是有的.以后去的话还是可以做相关的工作. 是山东的省会,作为一个山东人回自己的省会发展还是说的过去的. 房价还算温和, 除了东面高新区猛涨以外,西面南面还是很靠谱的. 离北京很近,高铁1个半小时就到了. 离菏泽也不远,如果菏泽开了动车以后,应该也是2个小时以内的行程. 济南有很多老家的朋友 和 亲戚. 父母也是做了决定以后, 立马就动身去了济南, 不过一开始看房的方向是有点选错了,这也是我的问题.因为我一直在北京的缘故, 总是不由自主的去考虑二手房, 导致我父母浪费了很多时间去看二手房,济南的二手房都是那种很破很烂的那种,并且价格很高.最后立哥带着我父母去了一个新的楼盘,恒大的房子. 我父母一眼就看中了样板间,然后就跟我开始商量决定要买.我综合考虑了下这房子的优点 均价 9100 附近 未来出门就是地铁 离济南大学超近, 不知道为什么,我总感觉离大学近是好事. 离我立哥比较近 送精装修, 先不说是不是羊毛出在羊身上了, 因为我要一直在北京上班,没有时间去管装修的事. 虽然现在是列了那么多,但是当时只是脑子已经乱了,每天我在北京上着班,听着父母传来的信息,感觉父母也累到极限了, 也实在是不想让父母再去逛了,于是我立马拍板了,就他了.决定之后也就好说了,第二天4点50就起床然后高铁到了济南, 直接打车到了楼盘, 然后我亲自看了下样板间,看起来确实很不错!然后接下来就一路程序走下来, 认购 -&gt; 去银行面签 -&gt; 然后签合同. 一切算是尘埃落定了吧 下面是房子的一些照片","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://nogirlfriendexception.github.io/tags/Life/"}]},{"title":"聊一聊播放器控制层的Scroll吧","slug":"playerscroll","date":"2016-09-12T03:23:30.000Z","updated":"2016-10-07T13:30:05.000Z","comments":true,"path":"2016/09/12/playerscroll/","link":"","permalink":"http://nogirlfriendexception.github.io/2016/09/12/playerscroll/","excerpt":"","text":"从开始做android开发,一晃就两年十个月了, 算上实习的公司已经经历了三家公司, 不知道是巧合还是怎么三家都是做跟视频有关系的. 今天的记录跟视频有关系但是关系不打,主要是讲视频的控制层.现在回头想想之前做播放器控制层的时候,基本都是没有动过脑子的, 关于MotionEvent 也是一知半解,写出来的控制层的代码,都是从网上搜索到的.然后我看了看几家公司的代码, 基本上大家都是雷同的… 下面贴出来一个 示范代码, 网上随处可见. 反正这代码的逻辑就是算touch Down 下时的Event xy 坐标 然后看当前的Event 坐标 来判断用户 是做的什么操作,以及滑动了多少. 这段代码 大部分时间应该都是没问题的, 大家也都是这样做的.但是在用户做一些特殊操作的时候 就会有问题. 我举个例子:用户touch 到了屏幕中间,然后向右滑动, 然后滑动到最右面, 不要松手 往左滑动.再滑动到中间继续往左滑.你就会发现touch事件有断层, 并且滑动距离与 视频进退的比例不好设定. (这点尤为突出) 这些缺点 以及一些不如意的地方, 由于我描述能力不行, 可能说的不是太清楚, 只有实际开发碰见过这些问题的同学才会明白我说的是什么..之前自己也一直没有注意到这些细节上的问题, 偶尔的一次机会发现了这个体验问题, 决心要解决它,重新去搞一套比较舒服的Scroll 算法. 最后在烨哥+飞哥的共同帮助下,完成了一套暂时看起来还不错的Scroll算法, 所以写下了这篇文章来记录一下想法和实现. 以下是正文首先 我们要明确一件事情, 当用户手指touch down 到屏幕的一瞬间, 整个滑动过程, 用户滑动距离与视频改变的时间的比例,就已经确认了, 不能再因为任何原因改变, 一直到用户手指离开屏幕. 看图上面这条线是影片的时间线,0 就是视频起点d 就是影片的总长度Y 当前currentPosition下面这条线是用户touch点在屏幕上的位置线p是触摸左侧X坐标q 触摸右侧X坐标X touchDown的X坐标 其中需要说明的是 这里有个小细节, 很多人算触摸界限的时候,都习惯性设置0 和 ScreenWidth. 但是其实真正使用的时候, 是没有人会从0开始滑 或者滑到屏幕最右面的, 除非你是测试.所以 p 是设置的1个padding值,并不是 0, q 也不是ScreenWidth. 一般是ScreenWidth - padding. 这套代码的整体思想很简单, x(用户的触摸x坐标)随着用户的滑动不停的在改变, 我们要用x来算出相应的y(影片seek到的位置), 也就是一个二元一次方程. y = ax + b; 所以我们要来先算出 a 和 b的 值.首先是一些常量的初始化, 注释也都有说明,大家自行理解一下.leftTouch 就是手指x坐标离左面的值rightTouch 是离右面的值.touchRange 是总的触摸长度.rightDuration 是影片剩余的时间. 接着上面的说, 我们既然要算出a 和 b, 那么就需要 得到两组合适的 xy 值 代入公式.其中已经确定好的一组值 就是 X 和 Y 就是手指刚落下的时候 那一组. 我们需要做的就是找出另外一组x y 值. 情况其实只有四种 以屏幕触摸终点 对应影片的Duration. 以屏幕触摸中点 对应影片的Duration. 以屏幕触摸起点 对应影片的起点 以屏幕触摸中点 对应影片的起点 可以根据比较 x 与touchRange的比值 与 y 与duration的比值的大小,来确定具体使用哪种情况.比较口头的来说,也是有四种情况, 可以涵盖全部情况 影片已经播放的时间 比较短, 触摸的位置特别靠右. 影片已经播放的时间 比较短, 触摸的位置靠右,但是不是特别靠右 影片已经播放的时间 比较长, 触摸的位置特别靠左, 影片已经播放的时间 比较长, 触摸的位置靠左,但是不是特别靠左 具体代码如下,也是最核心的代码. 这个地方如果理解起来有点困难, 可以画一些图来感受一下,就能明白为什么这样对应了.得到 两组 xy 值以后, 代入二元一次方程, 算出 ab 以后就好说拉！ 以上就是整套Scroll的代码和解析了, 实际跑起来的效果特别好! 顺滑无比! 怎么滑动都不会有断层,而且无论用户触摸在哪里开始滑动,滑动距离与影片改变的时间都很舒服.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]},{"title":"你就是我的天使.","slug":"life","date":"2016-08-29T11:31:30.000Z","updated":"2016-10-07T13:29:13.000Z","comments":true,"path":"2016/08/29/life/","link":"","permalink":"http://nogirlfriendexception.github.io/2016/08/29/life/","excerpt":"","text":"相识 相识皆是偶然,几年前因为游戏的缘故和你相识, 最初因为天各一方,加上这样那样的原因,一直只是远远的和你沟通过,沟通的内容也大多是与游戏相关. 缘起 第一次对你产生兴趣竟然是偶尔的一次深夜, 你推荐给我了一首歌, 名字叫唉声叹气; 应该算是一个很冷门的歌曲了,并且是听不懂的粤语,但是不知道为什么深得我心. 在单曲循环了很多很多个夜晚以后, 开始对你这个小姑娘产生了兴趣, 然后你又陆续给我介绍了好几首歌曲, 都是我喜欢的那种. 陆陆续续发现了很多和你聊的来的地方 以及三观出乎意料的一致. 但是依然是由于这样那样的原因,并没有让我往前走出那一步. 每一次动心都默默的只是动心而已. 记着有一天下午和你聊天,聊到双方所期望的对方是什么样的,说到深处突然发现你我或许有一点合适. 但是因为分隔两地,这个话题也就戛然而止了. 时间就这样一天天的过, 转眼认识了两年多, 有一天你突然跟我说, 想离开家乡来北京闯一闯,看看外面的世界, 说真的, 当时我内心是激动的开心的, 但是很快冷静下来,沉住了气, 开始帮你分析利弊,以及如何说服家里. 内心是充满着期待和好奇的, 开始盼着你的到来. 但是我也告诉了自己,其实一切很难, 无论是 你摆脱家里的一切来到北京, 还是我摆脱一切的束缚,迈出那一步. 相见 等待是煎熬的,漫长的. 你说明天就要来北京了, 嘴上说着好啊好啊, 但是心里还是不敢彻底相信, 担心着这样那样的变数. 直到那个午后, 你如同一个小天使一样蹦蹦哒哒的出现在我面前, 我嘴上说着hi. 心里却说着 终于等来了你. 很快一切的一切都变得脆弱不堪一击, 我的世界里全部的打算 计划 担忧 迷茫 都变成一句话 我爱你,我要不顾一切和你在一起. 你让我明白了这世界上最美好的事, 就是我爱上了你,你也爱我. 你让我奋斗变得更有意义. 你让我对明天充满着期待. 你让我变得不可自拔. 你让我明白,你就是那个陪我走到最后的人,让我可以付出一切的人. 此生只求与你相伴终老.","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"http://nogirlfriendexception.github.io/tags/Life/"}]},{"title":"做lib的时候学习到的一种思路.","slug":"lib-experience","date":"2016-08-03T11:31:30.000Z","updated":"2016-10-07T13:28:44.000Z","comments":true,"path":"2016/08/03/lib-experience/","link":"","permalink":"http://nogirlfriendexception.github.io/2016/08/03/lib-experience/","excerpt":"","text":"废话不多说,前几天我在我的支付lib 中,提交了一段很简单的代码,可是cto却指出了有严重的问题.代码是这样的. 代码很简单也很容易理解, 我这是一个支付lib, 然后这个类提供了1个发起支付的函数,我拿到外部传给我的Charge 进行检验,检验完毕后,我会调用Ping++ 发起支付.其中那个Callback 就是对各种支付结果进行反馈的.是不是看起来没有什么问题? 但是我的cto 看到后 立马就指出来了一个非常严重的问题 是这样的. 当外部调用这个方法的时候, 外部一般是这样的 show a loading Dialog –&gt; xx.createPayment(xx, xx, Callback);然后在 Callback{ onPaySuccess(); onPayFailed();} 的回调中, 隐藏掉这个dialog. ok 看起来一切都是正常的.但是cto说,你要明白你是做lib的, 你是无法控制外部何时显示dialog的, 你需要做的是保证无论什么情况都能让调用者收到callback.但是你这样写法的话, 如果外部是这样写的xx.createPayment(xx, xx, Callback); –&gt; show a loading Dialog ;然后它恰巧OrderId 不符合规定,那么 他就会出现先收到错误的回调 然后显示dialog的情况.然后他的那个dialog 就再也不会消失了… 然后正确的写法应该是这样的. 相信你已经看懂了问题所在,通过post到队列的最后,来保证时序是正确的. 感谢烨哥,学到了很多.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]},{"title":"播放器重构中遇见的坑","slug":"mediaplayer-rebuild","date":"2016-06-06T10:47:30.000Z","updated":"2016-07-28T03:39:53.000Z","comments":true,"path":"2016/06/06/mediaplayer-rebuild/","link":"","permalink":"http://nogirlfriendexception.github.io/2016/06/06/mediaplayer-rebuild/","excerpt":"","text":"播放器重构中遇见的坑 最近一直在重构公司项目的播放器项目, 这次重构是借鉴了Bilibili开源的ijkPlayer 代码的 写法, 一个VideoView 对应各种播放器内核.(android mediaplayer, exoplayer, ijkplayer.)rendenview 与 Mediaplayer 层面 隔离开. 在开发过程中遇见了几个小坑. 播放器状态相关简单的来说, mediaplayer 和ijkplayer 在进入Preparing的状态中时, 是不会对视频本身进行缓冲的, 而仅仅是做了初始化播放器的工作, 也就是说在prepared完成之前, 是不会有buffer的生命周期回调的, 而是在prepared 之后, 才会开始进入buffering state. 但是exoplayer的理念和 这两者有一点小小的不同,exoplayer在 进入 preparing状态之后 初始化完成播放器以后,会对视频本身开始buffer, buffer到足够开始进行播放以后, 才会回掉 STATE_READY(Prepared)的状态.这会给上层做整套生命周期 造成一定的影响. 如图: androidmediaplayer/ ijkplayer 的初始化生命周期 IDLE –&gt; Preparing –&gt; Prepared –&gt; buffering –&gt; playing. exoplayer的 初始化生命周期 IDLE –&gt; preparing –&gt; buffering –&gt; prepared(ready) onCompletion 相关这三个播放器都有onCompletion的回调,这个回调其实很好理解,就是播放完成的时候会回调该生命周期,但是ijkplayer回调的时机是有问题的, 它不仅仅在播放完成的时候会回调该方法,而且在出现错误的时候也会回调该方法。播放器产生错误 –&gt; onError –&gt; onCompletion.我也跟IJK的作者提了issue;作者也承认了这个错误, 但是 他说 这并不重要, not on plan. SeekTo 相关android mediaplayer seekTo 到 mediaplayer.getDuration(); 也就是说 seek到最后 正常来说 是没有什么问题的.可以正常seek, 然后成功进入completed状态. 然后这个时候调用start. 也不会有什么问题 会进入Playing状态但是你如果再次seekTo mediaplayer.getDuration(); 再点播放 就会出问题了, Mediaplayer 内部状态已经混乱了.对于这件事 我不知道为什么网上搜不到很多相关的问题, 可能是我太无聊了或者我使用方法不恰当的问题把.总而言之最后我做了WorkAround.每次执行seekTo的时候 我都会判断1下 是不是seekTo到最后 如果是 我就seekTo到getDuration() - 2000;然后 问题解决了 不过还好 这些问题如果理解的好,可以在上层进行规避.把三套播放器的生命周期 可以整合一套的。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]},{"title":"上传Android Library 到 bintray","slug":"upload-androidlib-bintray","date":"2015-11-09T03:42:30.000Z","updated":"2016-07-31T09:38:28.000Z","comments":true,"path":"2015/11/09/upload-androidlib-bintray/","link":"","permalink":"http://nogirlfriendexception.github.io/2015/11/09/upload-androidlib-bintray/","excerpt":"","text":"上传Android Library 到 bintray. 给公司写的videoplayer模块version one 完成了, 公司两个项目都需要用到这个模块,并且其中一个项目外包出去了,所以就要把这个模块上传到一个公共的lib库,方便外包的哥们去调用. 以及后续我这边更新维护. 然后选择了上传到bintray这个网站上. 说实话不是太了解这块儿东西,来这个公司之前一直是闷头写代码层的东西,每天就对着svn和eclipse, 什么maven,git,As,jcenter,bintray 等等完全没接触过. 谢谢公司给了机会去学习这些,但由于英语不好,在学习使用的途中踩了很多坑.这篇文章就是记录我把这个模块传到 bintray上 整个过程踩过的坑. 第一步 注册首先你需要 去bintray官网 注册个账号,这里就不过多描述了.你可以的.注册完毕以后 点击这里 进入maven管理界面然后 点击 创建新的package name 就是项目的名称licenses 我选择的是apache-2.0version control 我填的是github上的地址然后一切ok, 点击create package. 创建完毕. #第二步 寻找好用的publisher作者一开始不懂这个是干什么的,是公司的cto给我推荐了1个github地址,让我去学习那个,并且告诉我这个是最简单的上传方式.地址是 novoda其实英语好的哥们看到这应该已经知道怎么弄了 第一步 把这些配置到 你要发布的项目的 build.gradle文件中 这里需要注意的是apply plugin: ‘com.novoda.bintray-release’ 这句话 需要放在com.android.library 下面如图 第二步在build.gradle 文件中添加这个方法块。其中userorg 就是你的用户idgroupid 就是你的唯一包名artifactId 是你之前最初在bintary的maven中创建的那个package的名字,这里需要对应上 否则会上传失败.publishVersion 就是你的版本id咯下面2个随意填了 第三步$ ./gradlew clean build bintrayUpload -PbintrayUser=BINTRAY_USERNAME -PbintrayKey=BINTRAY_KEY -PdryRun=false在命令行中输出这些,其中需要把BINTRAY_USERNAME 替换成你的bintary的名字BINTRAY_KEY 替换成你的 BIntray的key ,其中key 可以点击你bintary中头像旁边的edit.进入API-Key 可以看到你的key,然后 copy进来就好了！这个时候打回车！ 然后就run起来了就好了.上传成功以后 你可以在你bintary 那个项目中 的管理页面看到这个 如果看到1.0.0 恭喜你 那就是上传成功, 但是这只是1个私人的,还不能让别人都用这个时候你需要点下面那个add to jcenter 然后申请加入jcenter用英语写几句描述 然后 提交 然后 就耐心等待就好了！！ #哦 对了有可能会报一个 :lint 什么什么找不到的错误 我在这卡了好一会儿.需要在android中添加这么一句 如图 就是那个lintOptions什么什么的 哦哦我想起来了 有可能会出现什么tools.jar找不到的 bug这个解决比较简单 有可能是你机器的JAVA_HOME没有指对比如我是rmbp 最初的JAVA_HOME是指向的mac 自带的1.6 jdk.修改成 androidstudio 指向的1.7的jdk 后就好了！！！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://nogirlfriendexception.github.io/tags/Android/"}]}]}